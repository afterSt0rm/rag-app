from typing import Annotated, Any, Dict, List, Optional, Sequence

from langchain_core.messages import BaseMessage
from langgraph.graph.message import add_messages
from typing_extensions import TypedDict


class DocumentResult(TypedDict, total=False):
    """Schema for a retrieved document."""

    content: str
    source: str
    collection: str
    metadata: Dict[str, Any]
    score: Optional[float]


class ToolResult(TypedDict, total=False):
    """Schema for a tool execution result."""

    tool_name: str
    tool_input: Dict[str, Any]
    tool_output: Any
    success: bool
    error: Optional[str]


class AgentState(TypedDict, total=False):
    """
    State for the ReAct agent.

    This state is passed between nodes in the LangGraph workflow.
    The ReAct agent maintains conversation history as messages,
    which includes the reasoning trace (thoughts) and actions (tool calls).

    Attributes:
        messages: Conversation messages including system, human, AI, and tool messages.
                  Uses add_messages reducer to append new messages.
        query: The original user query being processed.
        collection_names: Optional list of collection names to search.
                          If None, agent will determine which collections to use.
        retrieved_documents: Documents retrieved from similarity search.
        tool_results: Results from tool executions for observability.
        response: The final response generated by the agent.
        tool_used: Name of the primary tool used (for observability).
        reasoning_steps: Number of reasoning steps taken by the agent.
        error: Error message if something went wrong.
        trace_id: LangFuse trace ID for observability.
        thread_id: Conversation thread ID for memory persistence.
    """

    # Core message state - uses add_messages reducer to append
    messages: Annotated[Sequence[BaseMessage], add_messages]

    # Query information
    query: str
    collection_names: Optional[List[str]]

    # Retrieved context
    retrieved_documents: Optional[List[DocumentResult]]

    # Tool execution tracking
    tool_results: Optional[List[ToolResult]]
    tool_used: Optional[str]
    tools_used: Optional[List[str]]  # All tools used during execution

    # Response
    response: Optional[str]

    # Agent control flow
    reasoning_steps: int
    max_steps_reached: bool

    # Error handling
    error: Optional[str]

    # Observability
    trace_id: Optional[str]
    thread_id: Optional[str]


class InputState(TypedDict):
    """
    Input state schema for the agent.

    This defines what can be passed when invoking the agent.
    """

    query: str
    collection_names: Optional[List[str]]
    thread_id: Optional[str]


class OutputState(TypedDict):
    """
    Output state schema for the agent.

    This defines what is returned after the agent completes.
    """

    query: str
    response: str
    reasoning_steps: int
    tool_used: Optional[str]  # Primary tool (first used)
    tools_used: Optional[List[str]]  # All tools used
    retrieved_documents: Optional[List[DocumentResult]]
    error: Optional[str]
    trace_id: Optional[str]


def create_initial_state(
    query: str,
    collection_names: Optional[List[str]] = None,
    thread_id: Optional[str] = None,
) -> AgentState:
    """
    Create an initial state for the agent.

    Args:
        query: The user's query to process.
        collection_names: Optional list of collections to search.
        thread_id: Optional thread ID for conversation memory.

    Returns:
        Initial AgentState with default values.
    """
    return AgentState(
        messages=[],
        query=query,
        collection_names=collection_names,
        retrieved_documents=None,
        tool_results=[],
        tool_used=None,
        tools_used=[],  # Initialize empty list for tracking all tools
        response=None,
        reasoning_steps=0,
        max_steps_reached=False,
        error=None,
        trace_id=None,
        thread_id=thread_id or "default",
    )
